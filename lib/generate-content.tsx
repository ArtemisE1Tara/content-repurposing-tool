"use server"

import { extract } from "@extractus/article-extractor"
import { OpenAI } from "openai"
import { trackGeneration, getUserUsageStats } from "@/lib/memberships"

type PlatformSelection = {
  twitter: boolean
  instagram: boolean
  linkedin: boolean
  email: boolean
}

type LimitsType = {
  input: number
  twitter: number
  instagram: number
  linkedin: number
  email: number
}

// Mock responses for development/preview when OpenAI API is not available
const mockResponses = {
  twitter: "This is a sample Twitter post that would be generated by the AI. #content #repurposing",
  instagram:
    "This is a sample Instagram caption that would be generated by the AI.\n\nIt includes multiple lines to make it engaging!\n\n#instagram #content #repurposing",
  linkedin:
    "I'm excited to share this professional LinkedIn post that would be generated by the AI. It's designed to engage business professionals and includes a call to action.\n\nWhat are your thoughts on content repurposing? Let me know in the comments below!",
  email:
    "Check out our latest article on content repurposing! This email snippet is designed to get readers to click through to read more.",
}

// Create emoji versions of mock responses that are used only when useEmojis is true
const emojiMockResponses = {
  twitter: "✨ This is a sample Twitter post that would be generated by the AI. #content #repurposing",
  instagram:
    "📱 This is a sample Instagram caption that would be generated by the AI.\n\nIt includes multiple lines and emojis to make it engaging! 🔥\n\n#instagram #content #repurposing",
  linkedin:
    "🚀 I'm excited to share this professional LinkedIn post that would be generated by the AI. It's designed to engage business professionals and includes a call to action.\n\nWhat are your thoughts on content repurposing? Let me know in the comments below! 💬",
  email:
    "📧 Check out our latest article on content repurposing! This email snippet is designed to get readers to click through to read more. ✨",
}

export async function fetchArticleContent(url: string): Promise<string> {
  try {
    // Validate URL format
    let validatedUrl: URL;
    try {
      validatedUrl = new URL(url);
      // Make sure it's http or https
      if (!['http:', 'https:'].includes(validatedUrl.protocol)) {
        throw new Error("URL must start with http:// or https://");
      }
    } catch (urlError) {
      throw new Error("Please enter a valid URL (e.g., https://example.com/article)");
    }

    // Extract article content using article-extractor
    const article = await extract(validatedUrl.toString());

    if (!article) {
      throw new Error("Could not extract content from the provided URL");
    }

    if (!article.content) {
      throw new Error("The article was found but no content could be extracted");
    }

    // Clean up the content to remove any remaining HTML and optimize token usage
    const title = article.title || "";
    let cleanContent = article.content || "";
    
    // Enhanced cleaning process to ensure all HTML is removed
    cleanContent = cleanContent
      // Remove any remaining HTML tags
      .replace(/<\/?[^>]+(>|$)/g, " ")
      // Replace HTML entities with their text equivalents
      .replace(/&nbsp;/g, " ")
      .replace(/&amp;/g, "&")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&quot;/g, "\"")
      .replace(/&#39;/g, "'")
      // Normalize whitespace
      .replace(/\s+/g, " ")
      .replace(/\n\s*\n/g, "\n\n")
      .trim();
    
    // Extract the first 3 sentences as a summary for context saving
    const sentences = cleanContent.match(/[^.!?]+[.!?]+/g) || [];
    const summary = sentences.slice(0, 3).join(" ");
    
    // Optimize content length based on meaningful paragraphs
    const paragraphs = cleanContent.split("\n\n").filter(p => p.trim().length > 0);
    
    // Take only the most meaningful paragraphs (first few and last few)
    const maxParagraphs = 10; // Adjust based on typical article length
    let optimizedParagraphs;
    
    if (paragraphs.length <= maxParagraphs) {
      optimizedParagraphs = paragraphs;
    } else {
      // Take first paragraphs (typically most informative)
      const firstParagraphs = paragraphs.slice(0, Math.ceil(maxParagraphs * 0.7));
      // Take last paragraphs (typically conclusion)
      const lastParagraphs = paragraphs.slice(-(Math.floor(maxParagraphs * 0.3)));
      optimizedParagraphs = [...firstParagraphs, ...lastParagraphs];
    }
    
    // Construct the final cleaned content
    return `Title: ${title}\n\nSummary: ${summary}\n\nContent:\n${optimizedParagraphs.join("\n\n")}`;
  } catch (error: any) {
    console.error("Error fetching article:", error);
    
    // Provide more specific error messages based on error type
    if (error.message.includes("ENOTFOUND") || error.message.includes("ETIMEDOUT")) {
      throw new Error("Could not connect to the website. Please check the URL and try again.");
    }
    
    if (error.message.includes("403")) {
      throw new Error("Access to this website is forbidden. The site may be blocking automated requests.");
    }
    
    if (error.message.includes("404")) {
      throw new Error("The article was not found. Please check the URL and try again.");
    }
    
    // Return either the custom error message or a generic one
    throw new Error(error.message || "Failed to fetch article content. Please check the URL and try again.");
  }
}

// Check if we're in a browser environment
const isBrowser = () => typeof window !== "undefined"

export async function generateContent(
  content: string,
  platforms: PlatformSelection,
  tone = "professional",
  customInstructions = "",
  limits?: LimitsType,
  useEmojis = false,
): Promise<Record<string, string | any>> {
  // Check if user has reached their generation limit
  try {
    const stats = await getUserUsageStats();
    if (stats.isOverLimit) {
      throw new Error("You've reached your daily generation limit. Please upgrade your plan to continue generating content.");
    }
  } catch (error: any) {
    if (error.message.includes("upgrade your plan")) {
      throw error;
    }
    // If there's another error with stats, continue without checking limits
    console.error("Error checking usage limits:", error);
  }

  const result: Record<string, string | any> = {}
  const prompts: Record<string, string> = {}

  // Build tone instruction
  let toneInstruction = ""
  let emojiInstruction = ""
  
  // Adjust emoji instruction to be more tone-specific
  if (useEmojis) {
    switch (tone) {
      case "professional":
        emojiInstruction = "Include a few subtle, professional emojis where appropriate (e.g., ✓, 📊, 📈, 💼, 🔍)."
        break
      case "casual":
        emojiInstruction = "Include friendly, conversational emojis to make the content more relatable (e.g., 😊, 👋, 💯, ✨, 👍)."
        break
      case "humorous":
        emojiInstruction = "Add playful and humorous emojis to enhance the lighthearted tone (e.g., 😂, 🤣, 😜, 🙌, 🎉)."
        break
      case "enthusiastic":
        emojiInstruction = "Use energetic and expressive emojis to convey excitement (e.g., 🔥, 💪, 🚀, ⚡, 🌟)."
        break
      case "informative":
        emojiInstruction = "Add occasional relevant emojis to highlight key information points (e.g., 📝, ℹ️, 💡, 🔎, 📌)."
        break
      default:
        emojiInstruction = "Include appropriate emojis to enhance the message."
    }
  }

  switch (tone) {
    case "professional":
      toneInstruction = "Use a professional, business-appropriate tone."
      break
    case "casual":
      toneInstruction = "Use a casual, conversational tone as if talking to a friend."
      break
    case "humorous":
      toneInstruction = "Use a light-hearted, humorous tone with appropriate jokes or puns."
      break
    case "enthusiastic":
      toneInstruction = "Use an enthusiastic, energetic tone with excitement."
      break
    case "informative":
      toneInstruction = "Use an informative, educational tone focusing on facts and insights."
      break
    default:
      toneInstruction = "Use a professional, business-appropriate tone."
  }

  // Fix how custom instructions are incorporated into prompts
  const customInstructionsText = customInstructions.trim() 
    ? `\nAdditional specific instructions: ${customInstructions.trim()}`
    : "";

  if (platforms.twitter) {
    prompts.twitter = `
      You are a social media expert. Create a concise, engaging Twitter post (max ${limits?.twitter || 280} characters) based on the following content.
      ${toneInstruction}
      Include relevant hashtags and make it shareable.
      ${customInstructionsText}
      
      Content to repurpose:
      ${content}
      
      Format your response using markdown formatting where appropriate.
      ${useEmojis ? emojiInstruction : "Do not include any emojis in the response. No emojis at all. None."}
    `
  }

  if (platforms.instagram) {
    prompts.instagram = `
      You are a social media expert. Create an engaging Instagram caption based on the following content.
      ${toneInstruction}
      Include relevant hashtags${useEmojis ? ", use emojis appropriately," : ""} and format it with line breaks for readability.
      Keep it under ${limits?.instagram || 2200} characters.
      ${customInstructionsText}
      
      Content to repurpose:
      ${content}
      
      Format your response using markdown. Use formatting like bold for emphasis, bullet points for lists, and proper line breaks.
      ${useEmojis ? emojiInstruction : "Do not include any emojis in the response. No emojis at all. None."}
    `
  }

  if (platforms.linkedin) {
    prompts.linkedin = `
      You are a professional content writer. Create a LinkedIn post based on the following content.
      ${toneInstruction}
      Make it insightful and engaging for a business audience. Include a call to action.
      Keep it under ${limits?.linkedin || 3000} characters.
      ${customInstructionsText}
      
      Content to repurpose:
      ${content}
      
      Format your response using markdown. Use formatting like bold for important points, bullet points for lists, and proper headings and paragraphs.
      ${useEmojis ? emojiInstruction : "Do not include any emojis in the response. No emojis at all. None."}
    `
  }

  if (platforms.email) {
    prompts.email = `
      You are an email marketing expert. Create a concise email snippet (max ${limits?.email || 300} characters) based on the following content.
      ${toneInstruction}
      Make it compelling and designed to encourage the reader to click through to read more.
      ${customInstructionsText}
      
      Content to repurpose:
      ${content}
      
      Format your response using markdown. Use formatting like bold for important points and proper paragraphs.
      ${useEmojis ? emojiInstruction : "Do not include any emojis in the response. No emojis at all. None."}
    `
  }

  // Only generate content for selected platforms
  const selectedPlatforms = Object.keys(prompts) as Array<keyof typeof prompts>

  if (selectedPlatforms.length === 0) {
    return {}
  }

  // Check if we're in a preview/development environment without API access
  const isPreviewOrMissingAPIKey = !process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === "dummy" || isBrowser()

  if (isPreviewOrMissingAPIKey) {
    console.log("Using mock responses for preview/development")
    // Return mock responses for selected platforms
    for (const platform of selectedPlatforms) {
      const mockResponseSet = useEmojis ? emojiMockResponses : mockResponses;
      result[platform] = mockResponseSet[platform as keyof typeof mockResponses] || `Sample ${platform} content would appear here.`
    }
    return result
  }

  try {
    // Initialize OpenAI client - only if we're in a server environment with a valid API key
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    })

    // Process platforms one at a time
    for (const platform of selectedPlatforms) {
      try {
        // Set up base API options
        const apiOptions: any = {
          model: "gpt-4o-2024-08-06", // Default model
          messages: [
            {
              role: "system",
              content: "You are a content repurposing assistant. Your job is to create engaging content for various platforms based on the provided content.",
            },
            {
              role: "user",
              content: prompts[platform],
            },
          ],
          temperature: 0.7,
          max_tokens: 1024
        };

        const response = await openai.chat.completions.create(apiOptions);

        const generatedContent = response.choices[0]?.message?.content || ""
        result[platform] = generatedContent
        
        console.log(`Generated content for ${platform}, length: ${generatedContent.length}`);
        
        // Track this generation in the database with the content
        if (!isPreviewOrMissingAPIKey) {
          try {
            console.log(`Storing generation for ${platform} in database...`);
            // Track generation and return result for instant display
            const trackResult = await trackGeneration(platform, generatedContent.length, generatedContent);
            
            if (trackResult && typeof trackResult === 'object' && 'id' in trackResult) {
              console.log(`✅ Store success for ${platform}, ID: ${(trackResult as {id: string | number}).id}`);
              
              // Store the database record ID with the generation
              // This will be useful for immediate updating of the history list
              if (!result._meta) result._meta = {};
              if (!result._meta.dbRecords) result._meta.dbRecords = {};
              result._meta.dbRecords[platform] = trackResult;
            } else {
              console.log(`❌ Store may have failed for ${platform}, no result returned`);
              
              // Try to diagnose the issue - run a direct test after a short delay
              setTimeout(async () => {
                try {
                  const testResponse = await fetch('/api/test-db');
                  const testResult = await testResponse.json();
                  console.log('Database diagnostic test result:', testResult);
                } catch (testErr) {
                  console.error('Failed to run diagnostic test:', testErr);
                }
              }, 500);
            }
          } catch (trackError) {
            console.error(`Error tracking generation for ${platform}:`, trackError);
            // Don't throw here, just log the error and continue
          }
        } else {
          console.log('Skipping database storage (preview mode or missing API key)');
        }
      } catch (error) {
        console.error(`Error generating content for ${platform}:`, error)
        result[platform] = `Could not generate content for ${platform}. Please try again.`
      }
    }

    return result
  } catch (error) {
    console.error("Error in content generation process:", error)

    // Fallback to mock responses if OpenAI initialization fails
    for (const platform of selectedPlatforms) {
      result[platform] = mockResponses[platform as keyof typeof mockResponses] || `Sample ${platform} content would appear here.`
    }

    return result
  }
}

